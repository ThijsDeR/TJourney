/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: LIONDESERT (https://sketchfab.com/sherzod122007)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/3d-models/lucky-block-c1d5cfdbd2c24c3aa0a3b82286a19f76
title: Lucky Block
*/

import React, { useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import { getLuckyMove } from '../../App'

let dicePosition;
let textPosition;
let diceRotationX = 0;
let angle = 0;
let dd = 1;
let radius = 40;
let cx;           // X position of the dice
let cy;           // Y position of the dice
let cz = 100;     // Z position of the dice
let levitate = cz + 50;

export default function Dice(props) {
  const { nodes, materials } = useGLTF('/dice.gltf')
  return (
    <group {...props} dispose={null}>
      <group rotation={[-Math.PI / 2, 0, 0]}>
        <mesh geometry={nodes.Object_2.geometry} material={materials.material} />
      </group>
    </group>
  )
}

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// TODO: Make a function which can be called to lower the amount on the dice which is equal to the amount of steps the player still needs to take
//
// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Generate a random amount of steps
 * @param {*} amount maximum amount of steps a player can throw
 * @returns a random amount of steps beneath the maximum amount which also > 0 
 */
export function RandomCount(amount) {
  const stepAmount = Math.floor(Math.random() * (amount - 1) + 1);
  return stepAmount;
}

/**
 * function which is called to move the dice or to stop it
 */
export function throwDiceAnimation() {
  let speed = 1;
  let player = 0
  if (getLuckyMove() === true) {
    [cx, cy] = moveLuckyblock();
    textPosition = dicePosition + 20;
  } else {
    moveLuckyblockToCenter(speed, player)
    dicePosition = [player, cz, player];
    setTimeout(() => {
      textAnimation(0);
      if (levitate <= cz + 80) {
        levitate = levitate + 0.4;
      }
    }, 500)
  }
}

/**
 * Function to move the luckyblock above the player
 * @param {*} speed speed the lucky block goes to the middle
 * @param {*} player position of the player
 */
export function moveLuckyblockToCenter(speed, player) {
  if (cx > player || cy > player) {
    if (cx > player) {
      cx -= speed;
    }
    if (cy > player) {
      cy -= speed;
    }
    dicePosition = [cx, cz, cy]
  }
  if (cx < player || cy < player) {
    if (cx < player) {
      cx += speed;
    }
    if (cy < player) {
      cy += speed;
    }
  }
}

/**
 * Levitate the amount of steps from inside the dice
 */
export function textAnimation(optionalLevitation) {
  if (optionalLevitation === 0) {
    textPosition = [cx, levitate, cy];
  } else {
    textPosition = [cx, optionalLevitation, cy];
  }
}

/**
 * Move the Dice in a circle motion
 * @returns the new position of the dice
 */
export function moveLuckyblock() {
  // increase the angle of rotation
  angle += Math.acos(1 - Math.pow(dd / radius, 2) / 2);

  dicePosition = [radius * Math.cos(angle), 100, radius * Math.sin(angle)]

  return [radius * Math.cos(angle), radius * Math.sin(angle)]
}

/**
 * 
 * @returns 
 */
export function diceRotation() {
  diceRotationX = diceRotationX + 0.1;
  // return [Math.pow(diceRotationX,0.5), Math.pow(diceRotationX,0.8), Math.pow(diceRotationX,0.5)];
  return [0, diceRotationX, 0];
}

export function getDicePosition() {
  return dicePosition;
}

export function setDicePosition(_dicePosition) {
  dicePosition = _dicePosition;
}

export function getTextPosition() {
  return textPosition;
}

export function setTextPosition(_textPosition) {
  textPosition = _textPosition;
}

useGLTF.preload('/dice.gltf')
